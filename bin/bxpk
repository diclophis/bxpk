#!/usr/bin/env ruby

N_BYTES = [42].pack('i').size
N_BITS = N_BYTES * 8
N_MAX = 2 ** (N_BITS - 2) - 1

gem_dir = File.dirname(File.dirname(File.realpath(__FILE__)))
lib = File.join(gem_dir, "lib")
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require 'securerandom'
require 'json'
require 'easy_box_packer'

max_solutions = ARGV[0] ? ARGV[0].to_i : 4
thread_count = ARGV[1] ? ARGV[1].to_i : 1
stochastic = ARGV[2]

items = JSON.load($stdin.read, nil, symbolize_names: true, create_additions: false)
if stochastic
  items.shuffle!
end
itemsp = items.permutation

Thread.abort_on_exception = true
GC.enable

container = { dimensions: [20, 20, 20], weight_limit: 9999999999 }

factorial = begin
              (Math.gamma(items.length+1)).to_i
            rescue FloatDomainError
              N_MAX
            end

solutions = []
durations = []

min_score = N_MAX
max_score = -1
solutions_desired = ([factorial, max_solutions].min)

threads = []
all_bins = []

inbound = Queue.new
outbound = Queue.new

$stderr.puts [:spawning_producer, solutions_desired].inspect

producer = Thread.new {
  solutions_desired.times { |i|
    itemsn = itemsp.next

    if stochastic
      itemsn.shuffle!
    end

    inbound << itemsn
  }
  inbound.close
}

$stderr.puts [:spawning_consumers, thread_count].inspect

consumers = []
thread_count.times do
  consumers << Thread.new do
    while i = inbound.pop
      start = Time.now.to_f
      tbins = EasyBoxPacker.pack(
        container,
        i
      )
      raise tbins[:errors].inspect unless tbins[:errors].empty?
      outbound << [tbins, (Time.now.to_f - start).to_f]
    end
  end
end

until outbound.length == solutions_desired
  Thread.pass
end
outbound.close

$stderr.puts [:generation_completed]

loop do
  bins, duration = outbound.pop
  break if bins.nil? || duration.nil?

  durations << duration
  solutions << bins

  score = bins[:packings].length

  if score < min_score
    min_score = score
  end

  if score > max_score
    max_score = score
  end
end

average_item_time = durations.sum / durations.length.to_f

$stderr.puts [:sorting_completed, ("%02.5f" % average_item_time)]

$stderr.puts "solved #{solutions.length} min/max bins: #{min_score}/#{max_score}"

#mvc = EasyBoxPacker.find_smallest_container(items)
mvc = nil
#puts mvc.inspect

buffer_out_bytes = $stdout.write({:container => container, :items => items, :solutions => solutions, :mvc => mvc}.to_json)

$stderr.puts "persisted #{'%0.2f' % (buffer_out_bytes.to_f / 1000.0 / 1000.0)}mb"
