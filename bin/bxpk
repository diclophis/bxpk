#!/usr/bin/env ruby

N_BYTES = [42].pack('i').size
N_BITS = N_BYTES * 8
N_MAX = 2 ** (N_BITS - 2) - 1

gem_dir = File.dirname(File.dirname(File.realpath(__FILE__)))
lib = File.join(gem_dir, "lib")
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

require 'forwardable'
require 'securerandom'
require 'json'
require 'easy_box_packer'
require 'ordering_system'

max_solutions = ARGV[0] ? ARGV[0].to_i : 4
thread_count = ARGV[1] ? ARGV[1].to_i : 1
stochastic = ARGV[2]

items = JSON.load($stdin.read, nil, symbolize_names: true, create_additions: false)
if stochastic
  items.shuffle!
end
itemsp = items.permutation

Thread.abort_on_exception = true
GC.enable

container = { dimensions: [97, 59, 67], weight_limit: 9999999999 }

factorial = begin
              (Math.gamma(items.length+1)).to_i
            rescue FloatDomainError
              N_MAX
            end

#xxx = Mutex.new

sorted_by_x = OrderingSystem.new do |a, b|
  left = a[:packings].each_with_index.collect { |packing, bin_index| packing[:placements].collect { |placement| ((container[:dimensions][0] * bin_index.to_f) + placement[:position][0] + placement[:dimensions][0]) } }.flatten
  right = b[:packings].each_with_index.collect { |packing, bin_index| packing[:placements].collect { |placement| ((container[:dimensions][0] * bin_index.to_f) + placement[:position][0] + placement[:dimensions][0]) } }.flatten

  left.max > right.max
end

sorted_by_y = OrderingSystem.new do |a, b|
  left = a[:packings].each_with_index.collect { |packing, bin_index| packing[:placements].collect { |placement| (placement[:position][1] + placement[:dimensions][1]) } }.flatten
  right = b[:packings].each_with_index.collect { |packing, bin_index| packing[:placements].collect { |placement| (placement[:position][1] + placement[:dimensions][1]) } }.flatten

  left.max > right.max
end

sorted_by_z = OrderingSystem.new do |a, b|
  left = a[:packings].each_with_index.collect { |packing, bin_index| packing[:placements].collect { |placement| (placement[:position][2] + placement[:dimensions][2]) } }.flatten
  right = b[:packings].each_with_index.collect { |packing, bin_index| packing[:placements].collect { |placement| (placement[:position][2] + placement[:dimensions][2]) } }.flatten

  left.max > right.max
end

solutions = []
durations = []

min_score = N_MAX
max_score = -1
solutions_desired = ([factorial, max_solutions].min)

threads = []
all_bins = []

inbound = Queue.new
outbound = Queue.new

$stderr.puts [:spawning_producer, solutions_desired].inspect

producer = Thread.new {
  solutions_desired.times { |i|
    itemsn = itemsp.next

    if stochastic
      itemsn.shuffle!
    end

    inbound << itemsn
  }
  inbound.close
}

$stderr.puts [:spawning_consumers, thread_count].inspect

consumers = []
thread_count.times do
  consumers << Thread.new do
    while i = inbound.pop
      start = Time.now.to_f
      bins = EasyBoxPacker.pack(
        container,
        i
      )
      raise bins[:errors].inspect unless bins[:errors].empty?
      outbound << [bins, (Time.now.to_f - start).to_f]
      sorted_by_x.order_by(bins[:uuid], bins)
      sorted_by_y.order_by(bins[:uuid], bins)
      sorted_by_z.order_by(bins[:uuid], bins)
    end
  end
end

time_start = Time.now.to_f
#until outbound.length == solutions_desired
#  Thread.pass
#end
#outbound.close
#
#$stderr.puts [:generation_completed]

outbound_handled = 0

until outbound_handled == solutions_desired
  if Time.now.to_f - time_start > 2.0
    $stderr.puts([:progress, outbound.length, outbound_handled, solutions_desired].inspect)
    time_start = Time.now.to_f
  end

  bins, duration = outbound.pop

  if bins.nil? || duration.nil?
    Thread.pass
    next
  end

  outbound_handled += 1

  durations << duration
  solutions << bins

  ##Thread.new {
  ##a = Thread.new {
  # sorted_by_x.order_by(bins[:uuid], bins)
  ##}
  ##b = Thread.new {
  # sorted_by_y.order_by(bins[:uuid], bins)
  ##}
  ##c = Thread.new {
  # sorted_by_z.order_by(bins[:uuid], bins)
  ##}
  ##[a, b, c].collect(&:join)
  ##}

  score = bins[:packings].length

  if score < min_score
    min_score = score
  end

  if score > max_score
    max_score = score
  end

end

average_item_time = durations.sum / durations.length.to_f

$stderr.puts [:sorting_completed, ("%02.5f" % average_item_time)]

$stderr.puts "#{outbound_handled}/#{solutions_desired} -- solved #{solutions.length} min/max bins: #{min_score}/#{max_score}"

#mvc = EasyBoxPacker.find_smallest_container(items)
mvc = nil
#puts mvc.inspect

buffer_out_bytes = $stdout.write({
  :container => container,
  :items => items,
  :solutions => (solutions.slice(0, 4) || []) + (solutions.slice(-4, 4) || []),
  :solutions_x => (sorted_by_x.items.slice(0, 4) || []) + (sorted_by_x.items.slice(-4, 4) || []),
  :solutions_y => (sorted_by_y.items.slice(0, 4) || []) + (sorted_by_y.items.slice(-4, 4) || []),
  :solutions_z => (sorted_by_z.items.slice(0, 4) || []) + (sorted_by_z.items.slice(-4, 4) || []),
  :mvc => mvc}.to_json)

$stderr.puts "persisted #{'%0.2f' % (buffer_out_bytes.to_f / 1000.0 / 1000.0)}mb"
